Conway's Game of Life is a process that takes place on an infinite square grid, where each square can be in one of two states: alive or dead(depicted via black and white squares, respectively, in this book). The squares(which we typically call cells) then evolve in discrete timesteps(called generations or ticks) according to the following two rules:

* If a cell is alive, it comes to life in the next generation if it has exactly 3 live neighbors; otherwise it dies.
* If a cell is dead, it comes to life in the next generation if it has exactly 3 live neighbors; otherwise it stays dead.

We note that these rules are applied to every square in the grid simultaneously, and a "neighbor" in these rules refers to any of the 8 cells that it touches either along a side or at a corner, as in Figure 1.1. As an example of how these rules work, consider what happens to the straight line of 4 alive cells depicted in Figure 1.2. The leftmost and rightmost cells in the line both only have one live neighbor, so they die, while the two central cells above and below the line each have exactly 3 live neighbors, so they come to life. This leaves us with $3\times2$ rectangle of live cells, so we say that the line of 4 live cells is a parent of the $3\times2$  rectangle of live cells, or equivalently that the $3\times2$ rectangle is a child of the line of 4 cells. We then apply the evolution rules again: this time , the two central cells in the rectangle are overpopulated and die, while the dead cells to their immediate left and right have exactly 3 live neighbors and thus come to life.

After this point, if we apply the evolution rule again, nothing changes; each of the live cells have 2 live neighbors and thus live to the next generation, and no dead cell has exactly 3 live neighbors, so they all stay dead. A pattern like this that remains unchanged from one generation to the next is called a still life.

As we saw in this example, there was no input on our part once the pattern started evolving: we just applied the game's rules and passively watched what happened from one generation to the next unique and unexpected ways, and that is what this book is about. We will see patterns that move back and forth periodically between a finite number of different configurations, patterns that move through the Life grid over time, and patterns that create an infinitely growing family of other patterns. We will collide patterns with each other to crate more compllicated patterns, which we will then erase with even more patterns. We will construct logical circuitry with Life objects that allow us to simulate arbitrary computation within the Life universe, and we will construc patterns that do remarkable things like list the prime numbers or print out the decimal igits of $\pi$ . And all of this will work simply based on the two simple life and death rules we described earlier. 

This all leads to a very natural question: why those rules? Why not have a dead cell  come to life only in the case that it has exactly 4 live neighbors?  Why not have a live cell stay alive if it has exactly rules that can be applied to 2D square grid of alive and dead cells that simply depend on the numbers of live and dead neighbors that lead to a cell staying alive or coming to life. However, the following three properties make Life special (but by no means unique):

* Its rules are simple. For example, having a live cell alive if it has exactly 2 or 3 live neighbors is a more "natural" rule than having a live cell stay alive if it has exactly 1,2,4, or 7 live neighbors. This can be justified a bit by arguing that, to model something like a biological system, a cell should die of overcorwding if it has "too many" neighbors(e.g. since there won't be enough resources to support all of the live cells), and it should die of isolation if it has "too few" neighbors. The exact threshold for "too many" and "too few" is debateble, but pinned down at least somewhat by the next point.
* It strikes a balance between being chaotic and stable. Many rules(e.g., almost any rule in which a cell is born when it has 2 live neighbors) cause far too many births for anything to stabilize. These rules are thus "too chaotic", making it almost impossible for us to construct interesting objects. On the other hand, most rules in which cells are not born when they have 3 (or fewer) live nieghbors typically lead to a ptterns dying off extremely quickly and thus being "too stable" to be interesting. Life strikes a good balance of patterns typically staying alive but not overtaking the entire grid.
* It is historical. This is perhaps a bit of an unstatisfying reason, but part of the interest in Life simply comes from the fact that historically it is the most well-studied rule, and it is fun to see how far we can push one very well-studied rule, rather than dividing our attention and making moderate progress on multiple rules.

Nonetheless, other birth and death rules are sometimes studied as well, and for brevity they are typically described using a reulstring of the form Bx/Sy, where we replace "x" by all number of live neighbors that lead to the birth of a dead cell, and we replace "y" by all number of live neighbors that lead to the survival of a live cell. For example, the Game of Life is described by the rulestring B3/S23. We will discuse other rules much later, in Chapter 12, when we develop machinery that lets us run other celluar automata within Life.

There are also many more exotic ways to change the Game of Life beyond just changing the numbers of neighbors that cause cells to be alive. For example, we could have considered a neighbor of a cell to only be one of the 4 cells that shaes one of its isdes as in Figure 1.3, not just a corner(this 4-cell neighborhood is called the von Neumann neighborhood, whereas the 8-cell neighborhood used by Life is called the Moore neighborhood). We could have considered a hexagonal or triangular grid instead of a square one, or a 1D or 3D grid instead of a 2D one. We could have constructed the game in such a way that not only the number of live neighbors matters, but also their relative positions-such rules are konwn as isotropic rules, or INT rules(short for "istropic non-totalistic").

These are all potentially insteresting modifications to make, and they fall under the general umbrella of cellular automata(CA), but we will not consider them any further until Chapter 12. Instead, as we emphasize one final time, our goal is to take the Game of Life cellular automation itself and push it to its farthest limits.